Backend Interview Answers for FFSD Project

1. Authentication & JWT:
   - JWT token verification is implemented in `routes/authRoutes.js` in the `verifyJWTFromCookie` function.
   - The `verifyJWTFromCookie` function retrieves the token from `req.cookies?.token`, verifies it using `jwt.verify(token, process.env.JWT_SECRET)`, and returns decoded user info (id, userType) if valid. It handles token expiration and invalid tokens by returning null.
   - The `isAuthenticated` middleware checks for session data first (`req.session.user`), then falls back to JWT via `verifyJWTFromCookie`. If JWT is found, it fetches full user details from the database and populates `req.user`. It redirects to signin for page requests or returns 401 for API requests if neither is present.
   - JWT tokens are generated in the signin route (`/signin` in `authRoutes.js`) using `jwt.sign({ id: user._id, userType }, process.env.JWT_SECRET, { expiresIn: remember ? '7d' : '1h' })` and set as httpOnly cookies with options for security.
   - When a JWT token expires, `verifyJWTFromCookie` catches the `TokenExpiredError`, logs it, and returns null, causing the middleware to treat the user as unauthenticated.

2. Cart Logic:
   - Cart functionality is implemented in `controllers/customerPurchaseController.js` and routed through `routes/customerRoutes.js`.
   - The session-based cart uses `req.session.cart` as an array of objects with `productId` and `quantity`. Middleware in `customerRoutes.js` ensures the cart array exists in the session.
   - The `addToCart` function validates product availability by checking if the product is active, calculating available stock (target_quantity - sold_quantity or stock_quantity), and ensuring the requested quantity doesn't exceed remaining stock including existing cart items.
   - Cart data is stored in the user's session (`req.session.cart`) and persists across requests until the session expires or is cleared (e.g., after checkout).
   - The checkout process validates cart contents, customer info, and stock; simulates payment; decrements stock; updates customer records; and clears the session cart.

3. Middleware & Security:
   - Authentication middleware includes `isAuthenticated`, `isBrand`, `isInfluencer`, and `isCustomer` from `authRoutes.js`, supporting both session and JWT. Route-specific middleware like `verifyInfluencer` and `verifyBrandId` in their respective route files check user types and ownership.
   - CORS is configured in `app.js` with allowed origins from environment variables, credentials enabled, and specific methods/headers allowed.
   - Security measures include Helmet for headers, session configuration with secure cookies in production, httpOnly and sameSite settings, and bcrypt for password hashing.
   - The application supports dual authentication: sessions for EJS pages and JWT cookies for React API requests, with middleware checking both sources.

4. Database & Models:
   - MongoDB models are structured in the `config/` directory (e.g., `BrandMongo.js`, `InfluencerMongo.js`, `CustomerMongo.js`, `ProductMongo.js`, `CampaignMongo.js`), each defining schemas for their respective entities.
   - Database connection and initialization are handled in `models/mongoDB.js` with `connectDB()` and admin user setup.
   - User passwords are hashed using bcrypt in signup routes and verified during signin by comparing hashes.
   - Campaigns relate to brands (via `brand_id`), products (via `campaign_id`), and influencers (via `CampaignInfluencers` collection linking campaigns and influencers).

5. API Routes & Controllers:
   - Routes are organized by user type: `authRoutes.js` for authentication, `brandRoutes.js` for brands, `influencerRoutes.js` for influencers, `customerRoutes.js` for customers, and `adminRoutes.js` for admins.
   - The customer purchase controller (`customerPurchaseController.js`) handles cart operations (getCartPage, addToCart, removeFromCart, checkoutCart), product details, campaign shopping pages, and rankings.
   - File uploads are handled via Cloudinary integration in `utils/cloudinary.js` and `utils/imageUpload.js`.
   - Notification handling is implemented in `utils/notificationService.js` and routed through `routes/notificationRoutes.js`.

6. Session Management:
   - Sessions are configured in `app.js` using express-session with a secret from environment variables, secure cookies in production, and a 24-hour max age.
   - Sessions store user data (id, email, userType, displayName) and cart data, while JWT tokens store minimal user info (id, userType) for stateless authentication.
   - Session cleanup happens automatically via expiration, or manually via `req.session.destroy()` in logout.

7. Error Handling & Validation:
   - Errors are handled via try-catch blocks in routes/controllers, with custom error responses. Global error middleware in `app.js` renders error pages or returns JSON.
   - Input validation includes checking required fields, email formats, password presence, and business logic (e.g., stock availability).
   - The application differentiates API requests (JSON responses) from page requests (EJS renders) using headers like `accept: application/json`.

8. Business Logic:
   - Campaigns are activated by setting `status: 'active'` in the database; management includes creation, content publishing, and metrics tracking.
   - Product stock is managed via `target_quantity` and `sold_quantity` fields; available stock is calculated as `target_quantity - sold_quantity`.
   - Rankings aggregate data from CampaignMetrics, BrandAnalytics, InfluencerAnalytics, and social data, sorting by revenue, engagement, followers, etc.
   - The subscription system uses plans in `models/brandModel.js`, with middleware checking active subscriptions and periodic expiry checks.

9. Third-party Integrations:
   - Cloudinary is integrated in `utils/cloudinary.js` for image uploads, with configuration for uploads and URL generation.
   - Notification services are handled in `utils/notificationService.js`, likely for email/SMS via external providers.
   - Social media platforms for influencers are stored in `InfluencerSocials` collection with platform details, handles, and follower counts.

10. Performance & Scalability:
    - Database queries use lean() for performance, aggregation pipelines for complex calculations, and selective field population.
    - No explicit caching is implemented, but sessions provide temporary data storage.
    - Concurrent requests are handled via Node.js async nature and MongoDB's concurrency support.
    - Production measures include environment-based security settings, trust proxy for load balancers, and periodic cleanup tasks.
