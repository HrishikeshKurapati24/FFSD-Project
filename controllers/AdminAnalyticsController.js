const mongoose = require('mongoose');
const { InfluencerInfo } = require('../config/InfluencerMongo');
const { BrandInfo } = require('../config/BrandMongo');
const { CampaignInfluencers } = require('../config/CampaignMongo');
const Order = require('../config/OrderMongo');

const AdminAnalyticsController = {

    // Feature 1: Influencer ROI Score
    // Aggregates Order data to calculate total revenue generated by each influencer
    getInfluencerROI: async (req, res) => {
        try {
            const roiData = await mongoose.model('Order').aggregate([
                {
                    $match: {
                        status: { $in: ['paid', 'shipped', 'delivered'] } // Only count confirmed orders
                    }
                },
                {
                    $group: {
                        _id: '$influencer_id',
                        totalRevenue: { $sum: '$total_amount' },
                        totalCommission: { $sum: '$commission_amount' },
                        orderCount: { $sum: 1 }
                    }
                },
                {
                    $lookup: {
                        from: 'influencerinfos', // Collection name for InfluencerInfo
                        localField: '_id',
                        foreignField: '_id',
                        as: 'influencer'
                    }
                },
                {
                    $unwind: '$influencer'
                },
                {
                    $project: {
                        _id: 1,
                        name: '$influencer.fullName',
                        username: '$influencer.username',
                        totalRevenue: 1,
                        totalCommission: 1,
                        orderCount: 1,
                        // ROI metric: (Revenue - Commission) / Commission
                        // If commission is 0, avoid division by zero
                        roiScore: {
                            $cond: [
                                { $eq: ['$totalCommission', 0] },
                                0,
                                { $divide: [{ $subtract: ['$totalRevenue', '$totalCommission'] }, '$totalCommission'] }
                            ]
                        }
                    }
                },
                { $sort: { totalRevenue: -1 } } // Rank by Revenue
            ]);

            res.status(200).json({
                success: true,
                data: roiData
            });

        } catch (error) {
            console.error('Error in getInfluencerROI:', error);
            res.status(500).json({ success: false, message: 'Server Error' });
        }
    },

    // Feature 2: Brand-Influencer Matchmaking
    // Returns influencers recommended for a specific brand based on matching attributes
    getMatchmakingRecommendations: async (req, res) => {
        try {
            const { brandId } = req.params;
            const brand = await BrandInfo.findById(brandId);
            if (!brand) return res.status(404).json({ success: false, message: 'Brand not found' });

            const influencers = await InfluencerInfo.find({}).lean();

            const recommendations = influencers.map(inf => {
                let score = 0;
                let matches = [];

                // 1. Industry/Niche Match (40 points)
                // Normalize strings for comparison
                const brandIndustry = (brand.industry || '').toLowerCase();
                const infNiche = (inf.niche || '').toLowerCase();
                // Simple inclusion check
                if (brandIndustry && infNiche && (brandIndustry.includes(infNiche) || infNiche.includes(brandIndustry))) {
                    score += 40;
                    matches.push('Industry Match');
                }

                // 2. Location Match (30 points)
                // Assuming brand.target_regions is an array of strings
                const brandRegions = Array.isArray(brand.location) ? brand.location : [brand.location];
                const infLocation = (inf.location || '').toLowerCase();
                // Check if influencer location matches any brand target region
                const locationMatch = brandRegions.some(region =>
                    region && infLocation.includes(region.toLowerCase())
                );
                if (locationMatch) {
                    score += 30;
                    matches.push('Location Match');
                }

                // 3. Audience Match (30 points)
                // Match Gender
                if (brand.targetGender && inf.audienceGender &&
                    (brand.targetGender === 'All' || brand.targetGender === inf.audienceGender)) {
                    score += 15;
                    matches.push('Audience Gender Match');
                }

                // Match Age Range (Simple string match for now)
                if (brand.targetAgeRange && inf.audienceAgeRange &&
                    brand.targetAgeRange === inf.audienceAgeRange) {
                    score += 15;
                    matches.push('Audience Age Match');
                }

                // Random jitter for demo purposes if score is 0, so list isn't empty
                if (score === 0) score = Math.floor(Math.random() * 10);

                return {
                    influencer: {
                        _id: inf._id,
                        fullName: inf.fullName,
                        username: inf.username,
                        profilePicUrl: inf.profilePicUrl,
                        niche: inf.niche,
                        totalFollowers: inf.totalFollowers
                    },
                    matchScore: score,
                    matchReasons: matches
                };
            });

            // Sort by Score Descending
            recommendations.sort((a, b) => b.matchScore - a.matchScore);

            res.status(200).json({
                success: true,
                data: recommendations.slice(0, 20) // Top 20
            });

        } catch (error) {
            console.error('Error in getMatchmakingRecommendations:', error);
            res.status(500).json({ success: false, message: 'Server Error' });
        }
    },

    // Feature 3: Ecosystem Network Graph
    // Returns Nodes (Brands, Influencers) and Edges (Collaborations)
    getEcosystemGraphData: async (req, res) => {
        try {
            // 1. Nodes: Brands
            const brands = await BrandInfo.find({}).select('brandName logoUrl industry').lean();
            const brandNodes = brands.map(b => ({
                id: b._id.toString(),
                group: 'brand',
                label: b.brandName,
                image: b.logoUrl,
                value: 20 // Base size
            }));

            // 2. Nodes: Influencers
            const influencers = await InfluencerInfo.find({}).select('fullName profilePicUrl niche').lean();
            const influencerNodes = influencers.map(i => ({
                id: i._id.toString(),
                group: 'influencer',
                label: i.fullName || i.username,
                image: i.profilePicUrl,
                value: 15 // Base size
            }));

            // 3. Edges: Collaborations
            const collaborations = await CampaignInfluencers.find({
                status: { $in: ['active', 'completed'] }
            })
                .populate('campaign_id', 'brand_id budget')
                .select('influencer_id revenue')
                .lean();

            const links = collaborations
                .filter(c => c.campaign_id && c.campaign_id.brand_id) // Ensure valid refs
                .map(c => ({
                    source: c.campaign_id.brand_id.toString(),
                    target: c.influencer_id.toString(),
                    value: c.revenue || c.campaign_id.budget || 1, // Thickness based on money
                    status: c.status
                }));

            res.status(200).json({
                success: true,
                data: {
                    nodes: [...brandNodes, ...influencerNodes],
                    links: links
                }
            });

        } catch (error) {
            console.error('Error in getEcosystemGraphData:', error);
            res.status(500).json({ success: false, message: 'Server Error' });
        }
    }
};

module.exports = AdminAnalyticsController;
