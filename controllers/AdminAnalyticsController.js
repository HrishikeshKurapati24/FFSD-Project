const mongoose = require('mongoose');
const { InfluencerInfo } = require('../config/InfluencerMongo');
const { BrandInfo } = require('../config/BrandMongo');
const { CampaignInfluencers } = require('../config/CampaignMongo');
const Order = require('../config/OrderMongo');

const AdminAnalyticsController = {

    // Feature 1: Influencer ROI Score
    // Aggregates Order data to calculate total revenue generated by each influencer
    getInfluencerROI: async (req, res) => {
        try {
            const roiData = await mongoose.model('Order').aggregate([
                {
                    $match: {
                        status: { $in: ['paid', 'shipped', 'delivered'] } // Only count confirmed orders
                    }
                },
                {
                    $group: {
                        _id: '$influencer_id',
                        totalRevenue: { $sum: '$total_amount' },
                        totalCommission: { $sum: '$commission_amount' },
                        orderCount: { $sum: 1 }
                    }
                },
                {
                    $lookup: {
                        from: 'influencerinfos', // Collection name for InfluencerInfo
                        localField: '_id',
                        foreignField: '_id',
                        as: 'influencer'
                    }
                },
                {
                    $unwind: '$influencer'
                },
                {
                    $project: {
                        _id: 0,
                        influencerId: '$_id',
                        influencerName: {
                            $ifNull: ['$influencer.fullName', '$influencer.username']
                        },
                        username: '$influencer.username',
                        totalRevenue: 1,
                        totalCommission: 1,
                        orderCount: 1,
                        // Approximate campaignCount as distinct orders for now
                        campaignCount: '$orderCount',
                        avgOrderValue: {
                            $cond: [
                                { $eq: ['$orderCount', 0] },
                                0,
                                { $divide: ['$totalRevenue', '$orderCount'] }
                            ]
                        },
                        // Real-value / ROI metric: (Revenue - Commission) / Commission
                        // If commission is 0, avoid division by zero
                        roiScore: {
                            $cond: [
                                { $eq: ['$totalCommission', 0] },
                                0,
                                { $divide: [{ $subtract: ['$totalRevenue', '$totalCommission'] }, '$totalCommission'] }
                            ]
                        }
                    }
                },
                { $sort: { totalRevenue: -1 } } // Rank by Revenue
            ]);

            res.status(200).json({
                success: true,
                data: roiData
            });

        } catch (error) {
            console.error('Error in getInfluencerROI:', error);
            res.status(500).json({ success: false, message: 'Server Error' });
        }
    },

    // Feature 2: Brand-Influencer Matchmaking
    // Returns influencers recommended for a specific brand based on matching attributes
    getMatchmakingRecommendations: async (req, res) => {
        try {
            const { brandId } = req.params;
            const brand = await BrandInfo.findById(brandId);
            if (!brand) return res.status(404).json({ success: false, message: 'Brand not found' });

            const influencers = await InfluencerInfo.find({}).lean();

            const recommendations = influencers.map(inf => {
                let score = 0;
                let matches = [];

                // 1. Category Overlap Match (Critical - 50 points)
                const brandCats = Array.isArray(brand.categories) ? brand.categories : [];
                const infCats = Array.isArray(inf.categories) ? inf.categories : [];

                const matchedCats = brandCats.filter(cat =>
                    infCats.some(infCat => (infCat || '').toLowerCase() === (cat || '').toLowerCase())
                );

                if (matchedCats.length > 0) {
                    score += 50;
                    matches.push(`Category Match: ${matchedCats[0]}${matchedCats.length > 1 ? ' +' + (matchedCats.length - 1) : ''}`);
                }

                // 2. Industry/Niche Match (30 points)
                const brandIndustry = (brand.industry || '').toLowerCase();
                const infNiche = (inf.niche || '').toLowerCase();
                if (brandIndustry && infNiche && (brandIndustry.includes(infNiche) || infNiche.includes(brandIndustry))) {
                    score += 30;
                    matches.push('Industry/Niche Match');
                }

                // 3. Target Interests Match (20 points)
                const targetInterests = Array.isArray(brand.targetInterests) ? brand.targetInterests : [];
                const interestMatches = targetInterests.filter(interest =>
                    infCats.some(infCat => (infCat || '').toLowerCase() === (interest || '').toLowerCase()) ||
                    (inf.niche || '').toLowerCase().includes((interest || '').toLowerCase())
                );
                if (interestMatches.length > 0) {
                    score += 20;
                    matches.push('Target Interest Match');
                }

                // 4. Location Match (15 points)
                const brandLocation = (brand.location || '').toLowerCase();
                const infLocation = (inf.location || '').toLowerCase();
                const brandRegions = (brand.influenceRegions || '').toLowerCase();

                if (brandLocation && infLocation && (brandLocation.includes(infLocation) || infLocation.includes(brandLocation))) {
                    score += 15;
                    matches.push('Location Match');
                } else if (brandRegions && infLocation && brandRegions.includes(infLocation)) {
                    score += 10;
                    matches.push('Region Match');
                }

                // 5. Audience Demographic Match (15 points)
                if (brand.targetGender && inf.audienceGender &&
                    (brand.targetGender === 'All' || brand.targetGender === inf.audienceGender)) {
                    score += 15;
                    matches.push('Audience Gender Match');
                }

                // Random jitter for demo purposes if score is 0
                if (score === 0) score = Math.floor(Math.random() * 15);

                return {
                    influencer: {
                        _id: inf._id,
                        fullName: inf.fullName,
                        influencerName: inf.fullName || inf.username,
                        username: inf.username,
                        profilePicUrl: inf.profilePicUrl,
                        profilePicture: inf.profilePicUrl,
                        niche: inf.niche,
                        categories: inf.categories,
                        totalFollowers: inf.totalFollowers
                    },
                    matchScore: Math.min(score, 100),
                    score: Math.min(score, 100),
                    matchReasons: matches
                };
            });

            // Sort by Score Descending
            recommendations.sort((a, b) => b.matchScore - a.matchScore);

            res.status(200).json({
                success: true,
                data: recommendations.slice(0, 20) // Top 20
            });

        } catch (error) {
            console.error('Error in getMatchmakingRecommendations:', error);
            res.status(500).json({ success: false, message: 'Server Error' });
        }
    },

    // Feature 3: Ecosystem Network Graph
    // Returns Nodes (Brands, Influencers) and Edges (Collaborations)
    getEcosystemGraphData: async (req, res) => {
        try {
            // 1. Nodes: Brands
            const brands = await BrandInfo.find({}).select('brandName logoUrl industry').lean();
            const brandNodes = brands.map(b => ({
                id: b._id.toString(),
                group: 'brand',
                label: b.brandName,
                image: b.logoUrl,
                value: 20 // Base size
            }));

            // 2. Nodes: Influencers
            const influencers = await InfluencerInfo.find({}).select('fullName profilePicUrl niche').lean();
            const influencerNodes = influencers.map(i => ({
                id: i._id.toString(),
                group: 'influencer',
                label: i.fullName || i.username,
                image: i.profilePicUrl,
                value: 15 // Base size
            }));

            // 3. Edges: Collaborations
            const collaborations = await CampaignInfluencers.find({
                status: { $in: ['active', 'completed'] }
            })
                .populate('campaign_id', 'brand_id budget')
                .select('influencer_id revenue')
                .lean();

            const links = collaborations
                .filter(c => c.campaign_id && c.campaign_id.brand_id) // Ensure valid refs
                .map(c => ({
                    from: c.campaign_id.brand_id.toString(),
                    to: c.influencer_id.toString(),
                    value: 2, // Constant thickness for all collabs
                    color: { color: '#4CAF50', opacity: 0.8 }, // Green for collaborations
                    title: `Revenue: $${c.revenue || 0}`, // Tooltip
                    status: c.status
                }));

            res.status(200).json({
                success: true,
                data: {
                    nodes: [...brandNodes, ...influencerNodes],
                    links: links,
                    edges: links // Add edges for vis-network compatibility
                }
            });

        } catch (error) {
            console.error('Error in getEcosystemGraphData:', error);
            res.status(500).json({ success: false, message: 'Server Error' });
        }
    }
};

module.exports = AdminAnalyticsController;
